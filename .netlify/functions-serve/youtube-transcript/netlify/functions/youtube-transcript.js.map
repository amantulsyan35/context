{
  "version": 3,
  "sources": ["../../../../../../Users/aman/Desktop/context_sharing/netlify/functions/youtube-transcript.js"],
  "sourceRoot": "/var/folders/xp/1dy9c4zj6b70w7vcn91b99q40000gn/T/tmp-80252-DenOW9TvdxTF",
  "sourcesContent": ["const https = require('https');\n\nexports.handler = async (event) => {\n  // CORS preflight\n  if (event.httpMethod === 'OPTIONS') {\n    return {\n      statusCode: 200,\n      headers: {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type',\n        'Access-Control-Allow-Methods': 'GET, OPTIONS',\n      },\n      body: '',\n    };\n  }\n\n  const { videoId, startTime, endTime } = event.queryStringParameters || {};\n  if (!videoId || !startTime || !endTime) {\n    return json(400, { error: 'Missing required parameters: videoId, startTime, endTime' });\n  }\n\n  const start = parseFloat(startTime);\n  const end = parseFloat(endTime);\n\n  try {\n    // 1) Fetch the YouTube watch HTML\n    const html = await fetchUrl(`https://www.youtube.com/watch?v=${videoId}`);\n\n    // 2) Extract captionTracks JSON\n    const captionMatch = html.match(/\"captionTracks\"\\s*:\\s*(\\[[\\s\\S]*?\\])/);\n    if (!captionMatch) {\n      console.log('No captionTracks found');\n      return text(200, ''); // return empty string, UI will show fallback\n    }\n\n    let tracks;\n    try {\n      tracks = JSON.parse(captionMatch[1]);\n    } catch (e) {\n      console.error('Failed to parse captionTracks JSON:', e);\n      return text(200, '');\n    }\n\n    if (!Array.isArray(tracks) || tracks.length === 0) {\n      console.log('captionTracks array empty');\n      return text(200, '');\n    }\n\n    // 3) Prefer English, then any auto-EN, then first available\n    const en = tracks.find(t => t.languageCode === 'en' || t.languageCode?.startsWith('en'));\n    const enAsr = tracks.find(t => (t.kind === 'asr') && (t.languageCode === 'en' || t.languageCode?.startsWith('en')));\n    const track = en || enAsr || tracks[0];\n\n    if (!track?.baseUrl) {\n      console.log('No usable caption track baseUrl');\n      return text(200, '');\n    }\n\n    // Some baseUrls need fmt to ensure <text> nodes; append if missing\n    const baseUrl = track.baseUrl.includes('fmt=')\n      ? track.baseUrl\n      : `${track.baseUrl}&fmt=srv3`;\n\n    // 4) Fetch the caption XML\n    const subtitleXml = await fetchUrl(baseUrl);\n\n    // 5) Parse and slice to the time window\n    const clipSubtitles = parseSubtitles(subtitleXml, start, end);\n\n    console.log(`Found ${clipSubtitles.length} subtitle segments in range`);\n    return text(200, clipSubtitles.join(' '));\n  } catch (err) {\n    console.error('Transcript fetch failed:', err);\n    return json(500, { error: 'Failed to fetch transcript', details: err.message });\n  }\n};\n\nfunction fetchUrl(url) {\n  return new Promise((resolve, reject) => {\n    const req = https.get(\n      url,\n      {\n        headers: {\n          // Pretend to be a real browser to avoid some YT edge-cases\n          'User-Agent':\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n        },\n      },\n      (res) => {\n        let data = '';\n        res.on('data', (chunk) => (data += chunk));\n        res.on('end', () => {\n          if (res.statusCode === 200) resolve(data);\n          else reject(new Error(`HTTP ${res.statusCode}`));\n        });\n      }\n    );\n\n    req.on('error', reject);\n    req.setTimeout(15000, () => {\n      req.destroy();\n      reject(new Error('Request timeout'));\n    });\n  });\n}\n\nfunction decodeEntities(s) {\n  return s\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\");\n}\n\n// Parse <text start=\"..\" dur=\"..\"> ... </text> items and keep those overlapping [startTime, endTime]\nfunction parseSubtitles(xml, startTime, endTime) {\n  const out = [];\n  const re = /<text[^>]*start=\"([^\"]+)\"[^>]*(?:dur=\"([^\"]*)\")?[^>]*>([\\s\\S]*?)<\\/text>/g;\n  let m;\n  while ((m = re.exec(xml)) !== null) {\n    const textStart = parseFloat(m[1]);\n    const dur = m[2] ? parseFloat(m[2]) : 4;\n    const textEnd = textStart + dur;\n    if (\n      (textStart >= startTime && textStart <= endTime) ||\n      (textEnd >= startTime && textEnd <= endTime) ||\n      (textStart <= startTime && textEnd >= endTime)\n    ) {\n      // Remove any inline tags and decode entities\n      const raw = m[3].replace(/<[^>]*>/g, '').trim();\n      const clean = decodeEntities(raw);\n      if (clean) out.push(clean);\n    }\n  }\n  return out;\n}\n\nfunction json(statusCode, obj) {\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*',\n      'Cache-Control': 'public, max-age=3600',\n    },\n    body: JSON.stringify(obj),\n  };\n}\n\nfunction text(statusCode, body) {\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n      'Access-Control-Allow-Origin': '*',\n      'Cache-Control': 'public, max-age=3600',\n    },\n    body,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
